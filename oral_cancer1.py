# -*- coding: utf-8 -*-
"""Oral_Cancer1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VcAbnjgTuU6j67OefsjofgT1TrLAkS-E
"""

!pip install -q kaggle

from google.colab import files
files.upload()

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d ashenafifasilkebede/dataset

!unzip -q dataset.zip

import os
import cv2
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import keras
from keras.callbacks import EarlyStopping,ModelCheckpoint
import tensorflow as tf
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
from tqdm import tqdm

images = []
labels = []
for i in tqdm(['/content/train','/content/test','/content/val']):
    for subfolder in os.listdir(i):
        subfolder_path = os.path.join(i, subfolder)
        if not os.path.isdir(subfolder_path):
            continue
        for image_filename in os.listdir(subfolder_path):
            image_path = os.path.join(subfolder_path, image_filename)
            images.append(image_path)
            labels.append(subfolder)
df = pd.DataFrame({'image': images, 'label': labels})
df

plt.figure(figsize=(10,8))
ax = sns.countplot(x=df.label)
ax.set_xlabel("Class")
ax.set_ylabel("Count")
plt.title('The Number Of Samples For Each Class')
plt.grid(True)
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(50,50))
for n,i in enumerate(np.random.randint(0,len(df),50)):
    plt.subplot(10,5,n+1)
    img=cv2.imread(df.image[i])
    plt.imshow(img)
    plt.axis('off')
    plt.title(df.label[i],fontsize=25)

X_train, X_test1, y_train, y_test1 = train_test_split(df['image'], df['label'], test_size=0.3, random_state=42,shuffle=True,stratify=df['label'])
X_val, X_test, y_val, y_test = train_test_split(X_test1,y_test1, test_size=0.5, random_state=42,shuffle=True,stratify=y_test1)
df_train = pd.DataFrame({'image': X_train, 'label': y_train})
df_test = pd.DataFrame({'image': X_test, 'label': y_test})
df_val = pd.DataFrame({'image': X_val, 'label': y_val})

image_size = (224, 224)
batch_size = 32
datagen = ImageDataGenerator(
    rescale=1./255,
    horizontal_flip=True
)
train_generator = datagen.flow_from_dataframe(
    df_train,
    x_col='image',
    y_col='label',
    target_size=image_size,
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=True
)
test_generator = datagen.flow_from_dataframe(
    df_test,
    x_col='image',
    y_col='label',
    target_size=image_size,
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=False
)
val_generator = datagen.flow_from_dataframe(
    df_val,
    x_col='image',
    y_col='label',
    target_size=image_size,
    batch_size=batch_size,
    class_mode='categorical',
    shuffle=True
)

base_model = tf.keras.applications.DenseNet121(input_shape=(224,224,3),include_top=False,weights='imagenet')
base_model.trainable = False
model=keras.models.Sequential()
model.add(base_model)
model.add(keras.layers.BatchNormalization())
model.add(keras.layers.Flatten())
model.add(keras.layers.Dense(1024,activation=tf.nn.relu, kernel_regularizer=keras.regularizers.l2(0.01)))
model.add(keras.layers.Dropout(.3))
model.add(keras.layers.Dense(2,activation=tf.nn.softmax))
model.summary()

tf.keras.utils.plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True,show_dtype=True,dpi=120)

checkpoint_cb =ModelCheckpoint("Oral_Cancer_Detection_Model.h5", save_best_only=True)
early_stopping_cb =EarlyStopping(patience=3, restore_best_weights=True)
model.compile(optimizer ='adamax', loss='categorical_crossentropy', metrics=['accuracy',keras.metrics.SpecificityAtSensitivity(0.5),keras.metrics.AUC()])
hist=model.fit(train_generator,epochs=20,validation_data=val_generator,callbacks=[checkpoint_cb,early_stopping_cb])

hist_=pd.DataFrame(hist.history)
hist_

plt.figure(figsize=(15,10))
plt.subplot(2,2,1)
plt.plot(hist_['loss'],'b-o',label='Train_Loss')
plt.plot(hist_['val_loss'],'r-o',label='Validation_Loss')
plt.title('Train_Loss & Validation_Loss',fontsize=20)
plt.legend()
plt.subplot(2,2,2)
plt.plot(hist_['accuracy'],'b-o',label='Train_Accuracy')
plt.plot(hist_['val_accuracy'],'r-o',label='Validation_Accuracy')
plt.title('Train_Accuracy & Validation_Accuracy',fontsize=20)
plt.legend()
plt.subplot(2,2,3)
plt.plot(hist_['specificity_at_sensitivity'],'b-o',label='Train_specificity_at_sensitivity')
plt.plot(hist_['val_specificity_at_sensitivity'],'r-o',label='Validation_specificity_at_sensitivity')
plt.title('Train_Sensitivity & Validation_Sensitivity',fontsize=20)
plt.legend()
plt.subplot(2,2,4)
plt.plot(hist_['auc'],'b-o',label='Train_auc')
plt.plot(hist_['val_auc'],'r-o',label='Validation_auc')
plt.title('Train_AUC & Validation_AUC',fontsize=20)
plt.legend()
plt.show()

score, acc,sensitivity,auc = model.evaluate(test_generator)
print('Test Loss =', score)
print('Test Accuracy =', acc)
print('Test Sensitivity =', sensitivity)
print('Test AUC =', auc)

from sklearn.preprocessing import LabelEncoder

# Convert true labels to numeric
le = LabelEncoder()
y_test_encoded = le.fit_transform(y_test)   # Use the y_test from train_test_split

predictions = model.predict(test_generator)
y_pred = np.argmax(predictions,axis=1)

df = pd.DataFrame({'Actual': y_test_encoded, 'Prediction': y_pred})
display(df)

CM = confusion_matrix(y_test_encoded, y_pred) # Use y_test_encoded here
plt.figure(figsize=(6, 5))
sns.heatmap(CM, fmt='g', center=True, cbar=False, annot=True, cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

class_names=['Normal', 'OSCC']
batch = next(test_generator)
images= batch[0]
plt.figure(figsize=(50,50))
for n in range(32):
    plt.subplot(8,4,n+1)
    plt.imshow(images[n])
    plt.axis('off')
    plt.title(class_names[int(y_test[n])],fontsize=25)

CM = confusion_matrix(y_test,y_pred)
sns.heatmap(CM,fmt='g',center = True,cbar=False,annot=True,cmap='Blues')
CM



ClassificationReport = classification_report(y_test,y_pred)
print('Classification Report is :\n ', ClassificationReport )

y_pred_probs = model.predict(test_generator)
y_pred = np.argmax(y_pred_probs, axis=1)

# Convert true labels to numeric
le = LabelEncoder()
y_test_enc = le.fit_transform(y_test)   # y_test you created earlier

# Confusion Matrix
CM = confusion_matrix(y_test_enc, y_pred)
sns.heatmap(CM, fmt='g', annot=True, cmap='Blues',
            xticklabels=['Normal','OSCC'], yticklabels=['Normal','OSCC'])

# Classification Report
print(classification_report(y_test_enc, y_pred, target_names=['Normal','OSCC']))

import cv2
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import load_model

# Load best model
# Map 'softmax_v2' to the regular softmax activation
custom_objects = {"softmax_v2": tf.nn.softmax}

model = load_model("Oral_Cancer_Detection_Model.h5",
                   custom_objects=custom_objects,
                   compile=False)
class_names = ['Normal', 'OSCC']
model.compile(optimizer='adamax',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

def predict_single_image(img_path):
    img = cv2.imread(img_path)
    img = cv2.resize(img, (224, 224))   # Resize same as training
    img = img / 255.0                   # Normalize
    img = np.expand_dims(img, axis=0)   # Add batch dimension

    prediction = model.predict(img)
    predicted_class = np.argmax(prediction, axis=1)[0]
    confidence = np.max(prediction)

    print(f"Prediction: {class_names[predicted_class]} (Confidence: {confidence*100:.2f}%)")
    return class_names[predicted_class], confidence

# Example usage:
predict_single_image("/content/test/Normal/Normal_400x_150.jpg")

